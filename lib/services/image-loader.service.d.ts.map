{"version":3,"file":"image-loader.service.d.ts","sources":["image-loader.service.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { HttpClient } from '@angular/common/http';\nimport { File } from '@awesome-cordova-plugins/file/ngx';\nimport { WebView } from '@awesome-cordova-plugins/ionic-webview/ngx';\nimport { Platform } from '@ionic/angular';\nimport { ImageLoaderConfigService } from './image-loader-config.service';\nexport declare class ImageLoaderService {\n    private config;\n    private file;\n    private http;\n    private platform;\n    private webview;\n    /**\n     * Indicates if the cache service is ready.\n     * When the cache service isn't ready, images are loaded via browser instead.\n     */\n    private isCacheReady;\n    /**\n     * Indicates if this service is initialized.\n     * This service is initialized once all the setup is done.\n     */\n    private isInit;\n    private initPromiseResolve;\n    private initPromise;\n    private lockSubject;\n    private lock$;\n    /**\n     * Number of concurrent requests allowed\n     */\n    private concurrency;\n    /**\n     * Queue items\n     */\n    private queue;\n    private processing;\n    /**\n     * Fast accessible Object for currently processing items\n     */\n    private currentlyProcessing;\n    private cacheIndex;\n    private currentCacheSize;\n    private indexed;\n    private lockedCallsQueue;\n    constructor(config: ImageLoaderConfigService, file: File, http: HttpClient, platform: Platform, webview: WebView);\n    readonly nativeAvailable: boolean;\n    private readonly isCacheSpaceExceeded;\n    private readonly isWKWebView;\n    private readonly isIonicWKWebView;\n    private readonly isDevServer;\n    /**\n     * Check if we can process more items in the queue\n     */\n    private readonly canProcess;\n    ready(): Promise<void>;\n    /**\n     * Preload an image\n     * @param imageUrl Image URL\n     * @returns returns a promise that resolves with the cached image URL\n     */\n    preload(imageUrl: string): Promise<string>;\n    getFileCacheDirectory(): string;\n    /**\n     * Clears cache of a single image\n     * @param imageUrl Image URL\n     */\n    clearImageCache(imageUrl: string): Promise<void>;\n    /**\n     * Clears the cache\n     */\n    clearCache(): Promise<void>;\n    /**\n     * Gets the filesystem path of an image.\n     * This will return the remote path if anything goes wrong or if the cache service isn't ready yet.\n     * @param imageUrl The remote URL of the image\n     * @returns Returns a promise that will always resolve with an image URL\n     */\n    getImagePath(imageUrl: string): Promise<string>;\n    private processLockedQueue;\n    private getLockedState;\n    private awaitUnlocked;\n    private setLockedState;\n    private runLocked;\n    /**\n     * Returns if an imageUrl is an relative path\n     * @param imageUrl\n     */\n    private isImageUrlRelative;\n    /**\n     * Add an item to the queue\n     * @param imageUrl\n     * @param resolve\n     * @param reject\n     */\n    private addItemToQueue;\n    /**\n     * Processes one item from the queue\n     */\n    private processQueue;\n    /**\n     * Search if the url is currently in the queue\n     * @param imageUrl Image url to search\n     */\n    private currentlyInQueue;\n    /**\n     * Initialize the cache service\n     * @param [replace] Whether to replace the cache directory if it already exists\n     */\n    private initCache;\n    /**\n     * Adds a file to index.\n     * Also deletes any files if they are older than the set maximum cache age.\n     * @param file FileEntry to index\n     */\n    private addFileToIndex;\n    /**\n     * Indexes the cache if necessary\n     */\n    private indexCache;\n    /**\n     * This method runs every time a new file is added.\n     * It checks the cache size and ensures that it doesn't exceed the maximum cache size set in the config.\n     * If the limit is reached, it will delete old images to create free space.\n     */\n    private maintainCacheSize;\n    /**\n     * Remove a file\n     * @param file The name of the file to remove\n     */\n    private removeFile;\n    /**\n     * Get the local path of a previously cached image if exists\n     * @param url The remote URL of the image\n     * @returns Returns a promise that resolves with the local path if exists, or rejects if doesn't exist\n     */\n    private getCachedImagePath;\n    /**\n     * Normalizes the image uri to a version that can be loaded in the webview\n     * @param fileEntry the FileEntry of the image file\n     * @returns the normalized Url\n     */\n    private normalizeUrl;\n    /**\n     * Throws a console error if debug mode is enabled\n     * @param args Error message\n     */\n    private throwError;\n    /**\n     * Throws a console warning if debug mode is enabled\n     * @param args Error message\n     */\n    private throwWarning;\n    /**\n     * Check if the cache directory exists\n     * @param directory The directory to check. Either this.file.tempDirectory or this.getFileCacheDirectory()\n     * @returns Returns a promise that resolves if exists, and rejects if it doesn't\n     */\n    private cacheDirectoryExists;\n    /**\n     * Create the cache directories\n     * @param replace override directory if exists\n     * @returns Returns a promise that resolves if the directories were created, and rejects on error\n     */\n    private createCacheDirectory;\n    /**\n     * Creates a unique file name out of the URL\n     * @param url URL of the file\n     * @returns Unique file name\n     */\n    private createFileName;\n    /**\n     * Converts a string to a unique 32-bit int\n     * @param string string to hash\n     * @returns 32-bit int\n     */\n    private hashString;\n    /**\n     * Extract extension from filename or url\n     *\n     * @param url\n     * @returns\n     *\n     * Not always will url's contain a valid image extention. We'll check if any valid extention is supplied.\n     * If not, we will use the default.\n     */\n    private getExtensionFromUrl;\n}\n"]}